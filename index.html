<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Visualization based on the Pisa 2012 Dataset by 
		Guillermo Ramirez Camarero</title>
	<script src="http://d3js.org/d3.v3.min.js"></script>
	<style>
		h2{
			text-align: center;
		}
		/**{
			border: 1px solid red;
		}*/
		text{
			fill : #000;
			font-size: 8px;
		}
		.countryName{
			font-size: 14px;
		}
		.quantiles{
			stroke: #BBB;
			stroke-width: 1;
			stroke-dasharray: 2;
		}
        .box:hover {
            /*fill: red;*/
        }
        .whisker{
            /*shape-rendering: crispEdges;*/
        }
	</style>
	<script type="text/javascript">

	"use strict";// ensures no silent errors


	function draw(data){

		var margin = 75,
            width = 1000 - margin,
            height = 600 - margin,
            boxPadding = 5,
            boxWidth = width / data.length - boxPadding,
            medianLinePadding = 2;
        var integerFormat = d3.format(".0f");
        var highlightColor = "#e34a33";

        d3.select("body")
            .append ("h2")
            .text("Pisa 2012 (sampled data)");

        // we add a svg element where we will draw a box and whiskers plot
        // we store it in a variable so we can avoid selecting it 
        // with d3.select("svg")
        var svg = d3.select("body")
            .append("svg")
            .attr("width", width + margin)
            .attr("height", height + margin)
            .append('g')
            .attr('class', 'graph');
        // we define an ordinal scale:
        // a function that takes categories and returns colors.
        // we will use this function to assign a color to every country
        // according to their "quantile group", that is, they are sorted into
        // 4 groups according to their mean score in the PISA test.
        var quantileColor = d3.scale.ordinal()
        							.domain(["<q25", "<q50", "<q75", ">q75"])
        							.range(["#c2e699", "#78c679", 
        									"#31a354", "#006837"]);
        							/*.range(["#d7191c", "#fdae61", 
        									"#abd9e9", "#2c7bb6"]);*/
		// we define scale functions for the x and y axis.
        var xScale = d3.scale.linear()
                        .domain([0, data.length])
                        .range([0, width]);
		var yScale = d3.scale.linear()
						.domain([200,1800])
						.range([height, 0]);

        // http://alignedleft.com/tutorials/d3/axes
        // as explained in the link, g defines a group for the elements after
        // and call() hands off a selection to any function
        var yAxis = d3.svg.axis()
                  .scale(yScale)
                  .orient("bottom");

        svg.append("g").call(yAxis);

		// we draw horizontal lines for q10, q25, q50 and q75, q90 of the whole dataset
		// the values come from R
		var yQuantiles = [{
								"val" : 692.0664,
								"quantile" : 0.1
							},{	
								"val": 804.4097,
								"quantile": 0.25
							},{	
								"val": 941.5230,
								"quantile": 0.5
							},{	
								"val": 1080.3378,
								"quantile": 0.75
							},{	
								"val": 1195.2561,
								"quantile": 0.9
							}];

		svg.selectAll("line.quantiles")
			.data(yQuantiles)
			.enter()
			.append("line")
			.attr("x1", 0)
			.attr("y1", function (d){
				return yScale(d["val"]);
			})
			.attr("x2", width)
			.attr("y2", function (d){
				return yScale(d["val"]);
			})
			.attr("class", "quantiles")

        // next we select all rectangles (not yet created, so this returns an
        // empty selection). data() sees there are N values in the dataset, so
		// it calls enter() N times. enter() returns a placeholder selection for each datapoint that still doesn't have a rectangle appended (all of them)
		// append() places the rectangles 
		// clear explanation of this by Scott Murray in: 
		// http://alignedleft.com/tutorials/d3/making-a-bar-chart
		console.log(data);

        // sort the data before binding
        // note: mean_diff variable is positive if females do better than males
        // negative if males do better than females
        // diff ranking shows low numbers (1,2,3...) for negative values
        // (males better than females). Here the ranking does not make sense 
        // since the data is divergent. For this purpose I have added a function
        // diff_abs which measures the absolute difference regardless of gender.
        // lower absolute differences appear to the right when plotted.
        
        var sortKey = "mean";
        var sorter = {
            "mean" : (function (a,b){
                    return parseFloat(a["mean_ranking"]) - 
                           parseFloat(b["mean_ranking"]);
                }),
            "math" : (function (a,b){
                    return parseFloat(a["math_ranking"]) -
                           parseFloat(b["math_ranking"]);
                }),
            "read" : (function (a,b){
                    return parseFloat(a["read_ranking"]) - 
                           parseFloat(b["read_ranking"]);
                }),
            "mean_female" : (function (a,b){
                    return parseFloat(b["female_ranking"]) - 
                           parseFloat(a["female_ranking"]);
                }),
            "mean_male" : (function (a,b){
                    return parseFloat(b["male_ranking"]) - 
                           parseFloat(a["male_ranking"]);
                }),
            "sd" : (function (a,b){
                    return parseFloat(b["sd_ranking"]) - 
                           parseFloat(a["sd_ranking"]);
                }),
            "diff_abs" : (function (a,b){
                    return Math.abs(parseFloat(b["mean_diff"])) - 
                           Math.abs(parseFloat(a["mean_diff"]));
                }),
            "diff" : (function (a,b){
                    return parseFloat(a["diff_ranking"]) - 
                           parseFloat(b["diff_ranking"]);
                })
        }
        // for each feature there are two types of columns in the dataset: 
        // ones that contain the values, and others which only contain a 
        // precalculated ranking position

        // pairs the sorting keyword with the ranking column name in the dataset
        var sortMap = {
            "mean" : "mean_ranking",
            "math" : "math_ranking",
            "read" : "read_ranking",
            "mean_female" : "female_ranking",
            "mean_male" : "male_ranking",
            "sd" : "sd_ranking",
            "diff_abs" : "abs_diff_ranking",
            "diff" : "diff_ranking"
        }

        //pairs the sorting keyword with the value column name in the dataset
        //i am missing columns for male and female mean data
        var sortMap2 = {
            "mean" : "mean",
            "math" : "mean_math",
            "read" : "mean_read",
            "mean_female" : "female_ranking",
            "mean_male" : "male_ranking",
            "sd" : "sd",
            "diff_abs" : "mean_diff",
            "diff" : "mean_diff"
        }

        data.sort(sorter[sortKey]);

        svg.selectAll("line.whisker")
            .data(data)
            .enter()
            .append("line")
            .attr("x1", function (d,i){
                return xScale(i) + boxWidth/2;
            })
            .attr("y1", function (d){
                return yScale(d["bottom"]);
            })
            .attr("x2", function (d,i){
                return xScale(i) + boxWidth/2;
            })
            .attr("y2", function (d){
                return yScale(d["top"]);
            })
            .attr("stroke-width", 1)
            .attr("stroke", function (d){
                return quantileColor(d["mean_quantiles"]);
            })
            .attr("class", function (d, i){
                return "whisker c" + i;
            });

        svg.selectAll("rect.box")
        	.data(data)
        	.enter()
        	.append("rect")
        	.attr("x", function (d,i){ 
                return xScale(i);
        	})
        	.attr("y", function (d){
        		return yScale(d["q75"]);
        		})
        	.attr("width", boxWidth)
        	.attr("height", function (d){
        		return Math.abs(yScale(d["q75"])-yScale(d["q25"]));
        	}
        	).attr("fill", function (d){
        		return quantileColor(d["mean_quantiles"]);
        	})
            .attr("class", function (d, i){
                // two classes, one for type of element, another for number
                // of element
                return "box c"+i; 
            })
            .attr("ID", function (d, i){
                return i;
            })
            .on("mouseover", handleMouseOver)
            .on("mouseout", handleMouseOut);




       	// we use the same to draw and bind the lines
       	// note how we have to refer to line.median to avoid confusion
       	// with the already drawn line.whisker !
       	// we refer to line.median even though we don't assing the class name
       	// until the end of the chain in .attr("class", "median")
        svg.selectAll("line.median")
        	.data(data)
        	.enter()
        	.append("line")
        	.attr("x1", function (d,i){
        		return xScale(i) + medianLinePadding;
        	})
        	.attr("y1", function (d){
        		return yScale(d["q50"]);
        	})
        	.attr("x2", function (d,i){
        		return xScale(i) 
        				+ boxWidth - medianLinePadding;
        	})
        	.attr("y2", function (d){
        		return yScale(d["q50"]);
        	})
        	.attr("stroke-width", 1)
        	.attr("stroke", "white")
        	.attr("class", function (d,i){
                return "median c" + i;
            });
        
        svg.selectAll("text.top")
        	.data(data)
        	.enter()
        	.append("text")
        	.attr("x", function (d,i){
        		return xScale(i) + boxWidth;
        	})
        	.attr("y", function (d){
        		return yScale(d["top"]);
        	})
        	.text(function(d){
        		return integerFormat(d["top"]);
        	})
        	.attr("class", function (d,i){
                return "top c" + i;
            })
            .attr("visibility", "hidden");
        
        svg.selectAll("text.q75")
        	.data(data)
        	.enter()
        	.append("text")
        	.attr("x", function (d,i){
        		return xScale(i) + boxWidth;
        	})
        	.attr("y", function (d){
        		return yScale(d["q75"]);
        	})
        	.text(function(d){
        		return integerFormat(d["q75"]);
        	})
            .attr("class", function (d,i){
                return "q75 c" + i;
            })
            .attr("visibility", "hidden");
        
        svg.selectAll("text.q50")
        	.data(data)
        	.enter()
        	.append("text")
        	.attr("x", function (d,i){
        		return xScale(i) + boxWidth;
        	})
        	.attr("y", function (d){
        		return yScale(d["q50"]);
        	})
        	.text(function(d){
        		return integerFormat(d["q50"]);
        	})
            .attr("class", function (d,i){
                return "q50 c" + i;
            })
            .attr("visibility", "hidden");
        
        svg.selectAll("text.q25")
        	.data(data)
        	.enter()
        	.append("text")
        	.attr("x", function (d,i){
        		return xScale(i) + boxWidth;
        	})
        	.attr("y", function (d){
        		return yScale(d["q25"]);
        	})
        	.text(function(d){
        		return integerFormat(d["q25"]);
        	})
            .attr("class", function (d,i){
                return "q25 c" + i;
            })
            .attr("visibility", "hidden");
        
        svg.selectAll("text.bottom")
        	.data(data)
        	.enter()
        	.append("text")
        	.attr("x", function (d,i){
        		return xScale(i) + boxWidth;
        	})
        	.attr("y", function (d){
        		return yScale(d["bottom"]);
        	})
        	.text(function(d){
        		return integerFormat(d["bottom"]);
        	})
            .attr("class", function (d,i){
                return "bottom c" + i;
            })
            .attr("visibility", "hidden");
            

        svg.selectAll("text.countryName")
        	.data(data)
        	.enter()
        	.append("text")
        	.attr("x", function (d,i){
        		return xScale(i) + 0.7*boxWidth;
        	})
        	.attr("y", height - 20)
        	.text(function (d){
        		return d["country_code"];
        	})
        	.attr("text-anchor", "end")
        	.attr("transform", function (d,i){
        		return "rotate(-90," +
        				(xScale(i) + 0.7*boxWidth) + 
        				"," + 
        				(height - 20) +
        				")";
        	})
        	.attr("class", function (d,i){
                return "countryName c" + i;
            });

        svg.selectAll("text.sortValue")
            .data(data)
            .enter()
            .append("text")
            .attr("x", function (d,i){
                return xScale(i) + 0.7*boxWidth;
            })
            .attr("y", height - 30)
            .text(function (d){
                return integerFormat(d[sortKey]);
            })
            .attr("transform", function (d,i){
                return "rotate(-90," +
                        (xScale(i) + 0.7*boxWidth) + 
                        "," + 
                        (height - 30) +
                        ")";
            })
            .attr("class", "sortValue");

        // we add some buttons that allow us to change the sorting
        var buttons = d3.select("body")
                        .append("div")
                        .attr("class", "sortButton")
                        .selectAll("div")
                        .data(Object.keys(sortMap))
                        .enter()
                        .append("div")
                        .text(function (d){
                            return d;
                        });

        buttons.on("click", function (d){
            d3.select(".sortButton")
                .selectAll("div")
                .transition()
                .duration(500)
                .style("color", "black");
            d3.select(this)
                .transition()
                .duration(500)
                .style("background", "lightblue")
                .style("color", "white");
            var clickedName = this.innerHTML;

            // transitions for all elements
            d3.selectAll(".box")
                .transition()
                .duration(2000)
                .attr("x", function (d){
                    return xScale(d[sortMap[clickedName]]-1);
                });
            d3.selectAll(".whisker")
                .transition()
                .duration(2000)
                .attr("x1", function (d){
                    return xScale(d[sortMap[clickedName]]-1) + boxWidth/2;
                })
                .attr("x2", function (d){
                    return xScale(d[sortMap[clickedName]]-1) + boxWidth/2;
                });
            d3.selectAll(".median")
                .transition()
                .duration(2000)
                .attr("x1", function (d){
                    return xScale(d[sortMap[clickedName]]-1) 
                        + medianLinePadding;
                })
                .attr("x2", function (d){
                    return xScale(d[sortMap[clickedName]]-1) 
                        + boxWidth - medianLinePadding;
                });
            d3.selectAll(".countryName")
                .transition()
                .duration(2000)
                .attr("x", function (d){
                    return xScale(d[sortMap[clickedName]]-1) + 0.7*boxWidth;
                })
                // this transformation rotates again the coordinate system
                .attr("transform", function (d,i){
                    return "rotate(-90," +
                        (xScale(d[sortMap[clickedName]]-1) + 0.7*boxWidth) + 
                        "," + 
                        (height - 20) +
                        ")";
                });
            d3.selectAll(".top,.q75,.q50,.q25,.bottom")
                .transition()
                .duration(2000)
                .attr("x", function (d){
                    return xScale(d[sortMap[clickedName]]-1) + boxWidth;
                })

            d3.selectAll(".sortValue")
                .transition()
                .duration(2000)
                .attr("x", function (d){
                    return xScale(d[sortMap[clickedName]]-1) + 0.7*boxWidth;
                })
                .attr("transform", function (d,i){
                    return "rotate(-90," +
                        (xScale(d[sortMap[clickedName]]-1) + 0.7*boxWidth) + 
                        "," + 
                        (height - 30) +
                        ")";
                })
                .text(function (d){
                    return integerFormat(d[sortMap2[clickedName]]);
                });

        });
        
        // trying to change the properties of a clicked element
        // search for "d3 tooltips"
        // see this example! http://bl.ocks.org/Caged/6476579

        // show numbers when hover, and grey lines to compare
        // highlight country name
        // highlight color when clicked? or slight grey background?
        // mouse events with d3 example:
        // http://bl.ocks.org/WilliamQLiu/76ae20060e19bf42d774

        // mouse event handling functions
            function handleMouseOver (d, i) {
                d3.select(this).attr("fill", highlightColor);
                var classString = ".c" + this.getAttribute("ID");
                d3.select(".whisker" + classString)
                    .attr("stroke", highlightColor)
                    .attr("stroke-width", 2);
                d3.select(".countryName" + classString)
                    .attr("font-weight", "bold");

                d3.select(".top" + classString).attr("visibility", "visible");
                d3.select(".q75" + classString).attr("visibility", "visible");
                d3.select(".q50" + classString).attr("visibility", "visible");
                d3.select(".q25" + classString).attr("visibility", "visible");
                d3.select(".bottom" + classString).attr("visibility", "visible");
            }

            function handleMouseOut (d, i) {
                var classString = ".c" + this.getAttribute("ID");
                d3.select(this).attr("fill", quantileColor(d["mean_quantiles"]));
                d3.select(".whisker" + classString)
                    .attr("stroke", quantileColor(d["mean_quantiles"]))
                    .attr("stroke-width", 1);
                d3.select(".countryName" + classString)
                    .attr("font-weight", "normal");
                //remove text labels. comma notations means .top OR .q75 OR ...
                d3.selectAll(".top,.q75,.q50,.q25,.bottom")
                    .attr("visibility", "hidden");
            }
	}

	// what d3.tsv(filename, callback) returns is not the resulting object from
	// reading the tsv table, but a request which has to be pointed to a 
	// callback function. without the callback function it will not work!
	d3.tsv("pisa_both.tsv", draw);

	</script>
</head>
<body>
	<script type="text/javascript"></script>

</body>
</html>