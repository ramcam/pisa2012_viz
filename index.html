<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Visualization based on the Pisa 2012 Dataset by 
		Guillermo Ramirez Camarero</title>
	<script src="http://d3js.org/d3.v3.min.js"></script>
	<style>
		h2{
			text-align: center;
		}
		*{
			border: 1px solid red;
		}
		text{
			fill : #000;
			font-size: 8px;
		}
		.quantiles{
			stroke: #BBB;
			stroke-width: 1;
			stroke-dasharray: 2;

		}
	</style>
	<script type="text/javascript">
	/*
	var data = d3.tsv("pisa_both.tsv", function(d){
		return d;
	})*/
	"use strict";// ensures no silent errors
	
	function draw(data){

		var margin = 75,
            width = 1400 - margin,
            height = 600 - margin,
            boxPadding = 10,
            boxWidth = width / data.length - boxPadding,
            medianLinePadding = 2;
        var integerFormat = d3.format(".0f");

        d3.select("body")
            .append ("h2")
            .text("Pisa 2012 (sampled data)");

        // we add a svg element where we will draw a box and whiskers plot
        // we store it in a variable so we can avoid selecting it 
        // with d3.select("svg")
        var svg = d3.select("body")
            .append("svg")
            .attr("width", width + margin)
            .attr("height", height + margin)
            .append('g')
            .attr('class', 'graph');
        // we define an ordinal scale:
        // a function that takes categories and returns colors.
        // we will use this function to assign a color to every country
        // according to their "quantile group", that is, they are sorted into
        // 4 groups according to their mean score in the PISA test.
        var quantile_group_to_color = d3.scale.ordinal()
        							.domain(["<q25", "<q50", "<q75", ">q75"])
        							.range(["#c2e699", "#78c679", 
        									"#31a354", "#006837"]);
        							/*.range(["#d7191c", "#fdae61", 
        									"#abd9e9", "#2c7bb6"]);*/
		// we define scale functions for the y axis.
		var yScale = d3.scale.linear()
						.domain([0,1800])
						.range([height, 0]);

		// we draw horizontal lines for q10, q25, q50 and q75, q90 of the whole dataset
		// the values come from R
		var yQuantiles = [{
								"val" : 692.0664,
								"quantile" : 0.1
							},{	
								"val": 804.4097,
								"quantile": 0.25
							},{	
								"val": 941.5230,
								"quantile": 0.5
							},{	
								"val": 1080.3378,
								"quantile": 0.75
							},{	
								"val": 1195.2561,
								"quantile": 0.9
							}];

		svg.selectAll("line.quantiles")
			.data(yQuantiles)
			.enter()
			.append("line")
			.attr("x1", 0)
			.attr("y1", function (d){
				return yScale(d["val"]);
			})
			.attr("x2", width)
			.attr("y2", function (d){
				return yScale(d["val"]);
			})
			.attr("class", "quantiles")


        // next we select all rectangles (not yet created, so this returns an
        // empty selection). data() sees there are N values in the dataset, so
		// it calls enter() N times. enter() returns a placeholder selection for each datapoint that still doesn't have a rectangle appended (all of them)
		// append() places the rectangles 
		// clear explanation of this by Scott Murray in: 
		// http://alignedleft.com/tutorials/d3/making-a-bar-chart
		console.log(data);

        svg.selectAll("rect.box")
        	.data(data)
        	.enter()
        	.append("rect")
        	.attr("x", function (d,i){ 
        		return i * (width / data.length); 
        	})
        	.attr("y", function (d){
        		return yScale(d["q75"]);
        		})
        	.attr("width", boxWidth)
        	.attr("height", function (d){
        		return Math.abs(yScale(d["q75"])-yScale(d["q25"]));
        	}
        	).attr("fill", function (d){
        		return quantile_group_to_color(d["mean_quantiles"]);
        	})
        	.attr("class", "box");


        svg.selectAll("line.whisker")
        	.data(data)
        	.enter()
        	.append("line")
        	.attr("x1", function (d,i){
        		return i * (width / data.length) + boxWidth/2;
        	})
        	.attr("y1", function (d){
        		return yScale(d["bottom"]);
        	})
        	.attr("x2", function (d,i){
        		return i * (width / data.length) + boxWidth/2;
        	})
        	.attr("y2", function (d){
        		return yScale(d["top"]);
        	})
        	.attr("stroke-width", 1)
        	.attr("stroke", function (d){
        		return quantile_group_to_color(d["mean_quantiles"]);
        	})
        	.attr("class", "whisker");

       	// we use the same to draw and bind the lines
       	// note how we have to refer to line.median to avoid confusion
       	// with the already drawn line.whisker !
       	// we refer to line.median even though we don't assing the class name
       	// until the end of the chain in .attr("class", "median")
        svg.selectAll("line.median")
        	.data(data)
        	.enter()
        	.append("line")
        	.attr("x1", function (d,i){
        		return i * (width / data.length) + medianLinePadding;
        	})
        	.attr("y1", function (d){
        		return yScale(d["q50"]);
        	})
        	.attr("x2", function (d,i){
        		return i * (width / data.length) 
        				+ boxWidth - medianLinePadding;
        	})
        	.attr("y2", function (d){
        		return yScale(d["q50"]);
        	})
        	.attr("stroke-width", 1)
        	.attr("stroke", "white")
        	.attr("class", "median");

        svg.selectAll("text.top")
        	.data(data)
        	.enter()
        	.append("text")
        	.attr("x", function (d,i){
        		return i * (width / data.length) + boxWidth;
        	})
        	.attr("y", function (d){
        		return yScale(d["top"]);
        	})
        	.text(function(d){
        		return integerFormat(d["top"]);
        	})
        	.attr("class", "top");

        svg.selectAll("text.q75")
        	.data(data)
        	.enter()
        	.append("text")
        	.attr("x", function (d,i){
        		return i * (width / data.length) + boxWidth;
        	})
        	.attr("y", function (d){
        		return yScale(d["q75"]);
        	})
        	.text(function(d){
        		return integerFormat(d["q75"]);
        	})
        	.attr("class", "q75");

        svg.selectAll("text.q50")
        	.data(data)
        	.enter()
        	.append("text")
        	.attr("x", function (d,i){
        		return i * (width / data.length) + boxWidth;
        	})
        	.attr("y", function (d){
        		return yScale(d["q50"]);
        	})
        	.text(function(d){
        		return integerFormat(d["q50"]);
        	})
        	.attr("class", "q50");

        svg.selectAll("text.q25")
        	.data(data)
        	.enter()
        	.append("text")
        	.attr("x", function (d,i){
        		return i * (width / data.length) + boxWidth;
        	})
        	.attr("y", function (d){
        		return yScale(d["q25"]);
        	})
        	.text(function(d){
        		return integerFormat(d["q25"]);
        	})
        	.attr("class", "q25");

        svg.selectAll("text.bottom")
        	.data(data)
        	.enter()
        	.append("text")
        	.attr("x", function (d,i){
        		return i * (width / data.length) + boxWidth;
        	})
        	.attr("y", function (d){
        		return yScale(d["bottom"]);
        	})
        	.text(function(d){
        		return integerFormat(d["bottom"]);
        	})
        	.attr("class", "bottom");
        // could we make a function to draw a boxplot object
        // which would be bound to several values?



	}

	// what d3.tsv(filename, callback) returns is not the resulting object from
	// reading the tsv table, but a request which has to be pointed to a 
	// callback function. without the callback function it will not work!
	d3.tsv("pisa_both.tsv", draw);

	</script>
</head>
<body>
	<script type="text/javascript"></script>

</body>
</html>